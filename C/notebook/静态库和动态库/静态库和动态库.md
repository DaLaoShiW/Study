## 静态库和动态库
---

### 前言
---

1. 目标文件(.o) 和可执行程序(.out) 之间的区别
    * 目标文件之后绘画和其他的目标文件或者是库文件构建成标准的可执行程序(这个操作叫做链接，由链接器完成)
    * 链接器的主要作用在于将每一个模块中相互引用的部分处理好，使得模块之间可以协调工作
    * 库是代码的共享方式，静态库和动态库的只要形式在于链接形式的不同，他们都是目标文件的集合，再加上一些索引表项表征文件的信息，Linux 中是ELF文件格式
    * 一个C程序分为若干程序文件，每个程序文件单独编译生成目标文件，最后将所有目标链接，如果所有的函数符号和变量符号都找到正确地址则编译成功，生成可执行文件

2. 静态链接,动态链接
    * 静态链接: 由连接器在链接的时候将库的内容直接加入到可执行程序中
        1. Linux .a 为后缀, .lib 是 win 下的后缀
        2. 静态连接是连接器讲一个或者多个目标文件以及静态库被引用的目标文件完全链接到一个可执行文件中，由链接器完成所有工作，包括符号解析和重定位
        3. 链接之后的可执行程序可以直接被加载执行
        4. 代码体积大
    * 动态链接: 可执行程序在运行中才会动态的加载库进行链接，库的内容不会进入可执行程序中
        1. 代码体积小

3. Linux 环境下的使用方式
    * 为了使得程序扩展方便，具有通用性，可以采用插件的形式使用异步事件驱动模型，保证主程序的逻辑不变，将其他的业务通过动态链接库的形式加载进来，就是所谓的插件
    * Linux 内部实现和提供了加载和处理动态链接库的系统调用，很方便
        1. dlopen: 打开动态链接库
        2. dlsym:  查找动态库中函数并返回调用地址
        3. dlclose: 关闭动态链接库
    * LD_LIBRARY_PATH: 环境变量用于设置查找共享目录的路径,可以手动定义(export)
      LIBRARY_PATH: 静态库的连接文件搜索路径，上面的是动态库的
    * 新的库如果在 /lib | /usr/lib 中的话，系统可以默认的找到，否则需要添加到 /etc/ld.so.cache 文件中，或者运行 ldconfig 命令自动添加
    * 如果将所有的文件统一使用 gcc 编译成 a.out 文件本质上也是可以运行的，但是我们编译成静态库和动态库的本质是为了让库文件可以被共享，而统一编译则只让当前的一个文件使用了库文件
    * -l 查询的路径 (优先查找指定的目录和 LD_LIBRARY_PATH)
        1. ELF 文件的 DT_PATH 段
        2. 环境变量 LD_LIBRARY_PATH
        3. /etc/ld.so.cache 文件列表
        4. /lib | /usr/lib
        5. -L 指定的路径
    * 如果静态库和动态库同名的话，优先使用动态库，除非使用 -static 选项强制指定静态库

### 深入
---

1. 静态库
    1. 后缀是 .a
    2. 源文件生成一批目标文件 (.o), 每一个 (.o) 文件中都有自己的符号表(变量或者函数什么的)
    3. ar 命令将 .o 文件转化成 .a 文件，合成静态库
    4. 静态库的命名规则: libxxx.a, xxx 是库名
    5. 示例
        1. 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库
        2. 详见文件 add.h, add.c, test.c 
            ```shell
            gcc -c add.c                // create add.o
            ar crs libadd.a add.o      // 创建静态库, -c 创建, -r 如果当前插入的库名存在与其他的目录，覆盖
            gcc test.c -ladd -I. -L.    // -I 将当前目录加入头文件的搜索目录中，-L将当前目录键入文件的搜索路径中，这是为-l参数准备的
            ./a.out
            // 这时候即使删除了静态库文件 libadd.a a.out一样会执行
            ```

2. 动态库
    1. 后缀是 .so
    2. 动态库的命名规则: libxxx.so.major.minor, xxx 是库名，major是主版本号,minor是副版本
    3. 示例
        1. 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在
        2. 在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用,当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中,这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响。 
        3. 详见文件 add.h, add.c, test.c
        ```shell
        gcc --shared -fPIC -o libadd.so add.c       // --shared 共享, -fPIC 声明不要包含函数和变量的内存具体地址，因为动态链接不需要
        gcc test.c -I. -L. -ladd                    // 加入了 -L. 参数之后还是会报错，这是有原因跟，并不是加入了 -L. 参数就一劳永逸了,首先 -L. 参数只是告诉连接器将 libadd.so 中的函数的引用加入到对应的调用位置上，但是因为是动态链接，在之后还是需要制定动态库的存放地址才可以争取的将引用和对应的函数地址结合起来
        export LD_LIBRARY_PATH=.                    // 修改环境变量
        cp ./libadd.so /usr/lib                     // 一样可以
        ldd a.out                                   // 可以查看到可执行文件依赖的库
        ```

3. Gcc 编译参数解析
    1. --shared: 生成动态链接库，生成符号表，在 -I. -L. 的时候加入引用需要使用这个符号表
    2. -fPIC: 编译成独立的代码，否则动态链接实现的是代码拷贝到不同可执行程序中不能实现真正的共享,产生位置无关代码
    3. -L.: 连接的库在当前目录中
    4. -I.: 导入库的头文件目录
