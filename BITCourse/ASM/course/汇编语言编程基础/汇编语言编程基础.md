## 汇编语言编程基础

#### 汇编语言概述

1. 程序设计语言
   1. 机器语言 : 计算机可以直接识别的语言，二进制代码的机器指令表示，操作码 + 操作数
   2. 汇编语言 : 占用空间少，执行速度极快，可移植性差，难以书写和阅读
      1. 指令助记符
      2. 符号地址
      3. 标号
   3. 高级语言
2. Intel芯片是小端存储
3. Intel微处理器简介
   1. 8086系列都是16位
      1. 16位数据的运算和处理
      2. 20位地址线
      3. 寻址范围1MB($$2^{20}$$)
      4. 只运行在实模式下
   2. 80286
      1. 16位数据的运算和处理
      2. 24位地址线
      3. 寻址范围16M
      4. 引入保护模式，可以运行在实模式下和保护模式下
   3. 80386
      1. 32位数据总线和地址总线和寄存器
      2. 4GB寻址范围
4. 运行模式
   1. 实模式 : DOS
   2. 保护模式 : 特权级保护，多任务，内存分页管理
   3. 虚拟8086模式

#### 可见寄存器组

![img](http://images.cnitblog.com/blog/335617/201212/23173657-4b18dd2345214b91a627dbfa2cb2cf1b.png)

1. 寄存器

   1. 可见寄存器 : 编程人员可以使用的寄存器
   2. 不可见寄存器 : 系统程序运行的时候可以使用的寄存器

2. 可见寄存器分类

   * 通用寄存器(8个16位寄存器，前几个又可以独立的作为了2个8位寄存器使用)

     * 数据寄存器 : AX,BX,CX,DX
       * 用来保存操作数和运算结果的信息
       * 但是各自也有一些专门的用途(中断的功能号，独立的参数寄存器)
         * AX,AL,EAX : 累加器
         * BX : 寄存器间接寻址的时候可以使用
     * 指针寄存器
       * 堆栈指针寄存器 : SP
         * 存放当前的堆栈的栈顶的偏移量(栈的生长方向是从高地址到低地址生长)
         * 实模式下使用SP,保护模式下使用ESP
         * 一般都是压栈和弹栈操作自动修改的
       * 基址指针寄存器 : BP
         * 默认和SS堆栈段进行配合**随机存取**栈中的数据
     * 变址寄存器 : SI,DI
       * SI,ESI : 源变址寄存器，还可以用来存储偏移地址进行间接寻址操作的寄存器
       * DI,EDI : 目的变址寄存器

     使用准则

     1. 除了SP以外的寄存器可以用来存储操作数和中间结果

     2. 每个寄存器大致按照这个思路区划分，但是实际上每个寄存器都有独特的实现的功能

     3. 对于在80286,80386等扩展的寄存器中我们是完全兼容低位的寄存器的

        对于我们的寄存器的使用，在8086模式下是不会改变我们的高维的扩展寄存器的内容

   * 段寄存器

     1. 存储器使用分段和分页的组织方式，**存储器寻址的时候需要用到段寄存器**

     2. 段寄存器用来确定一个存储段在内存中的起始地址

     3. 一个程序可以用多个段组成(在8086模式下只有4个段寄存器，一段程序只可以访问4个段)

     4. 实模式下段寄存器存放当前运行的程序的段基址的高16位，保护模式下存放当前运行程序的段选择符(段基址，段长，段访问权限)

     5. 分类

        1. CS : 代码段基址

        2. DS : 数据段基址

           主数据段寄存器，默认情况下程序使用DS指向的段的数据，DS一定要保证指对否则程序指错了段

        3. SS : 堆栈段基址

        4. ES : 附加数据段基址

   * 控制寄存器

     1. 在程序中不可以直接引用控制寄存器名称
     2. 分类
        1. 指令指针寄存器(IP,EIP)
           * 和CS段配合指向**下一条**要执行的指令的地址
           * 存放偏移量的部分
           * 实模式下使用IP，保护模式下使用EIP
        2. 标志寄存器(状态寄存器)
           1. 运算结果特征
              1. CF : 进位标志(进位或者借位) : 检测无符号数**加减法**是否溢出,进位(1)
              2. PF : 奇偶校验位，Intel是奇校验
              3. AF : 辅助进位标志(16->10辅助进位)
              4. ZF : 零标志,计算结果是否为0
              5. SF : 符号标志位，负(1)
              6. OF : 有符号的溢出检测，超出(1)
           2. 控制标志特征
              1. IF : 中断允许标志位，(1)只能屏蔽硬件中断不能屏蔽软件中断
              2. DF : 方向标志,字符串操作指令需要(1)自动减
              3. TF : 陷阱标志位，用于程序调试(1)单步方式
              4. NT : 嵌套任务标志(1)返回到上一层的任务中，否则直接回复寄存器然后返回程序
              5. AC : 地址对齐检查标志

#### 存储器

1. 存储顺序

   * 最基本的存储单位是字节
   * Intel小端存储，低字节存放低地址

2. 实模式寻址(内存的第一个1MB空间)

   1. 矛盾 : 
      * 8086寄存器16位的字长，总线宽度是20字节
      * 16位字长机器寻找20位的总线地址
   2. 使用功能分段管理方式处理矛盾
      1. 内存单元地址
         * 段基地址 : 16
         * 偏移地址 : 16
      2. 程序给出的地址只是逻辑地址，必须要机器自动寻址才可以找到
      3. **因为机器字长是16位，所以段长是64KB(寻址寄存器[偏移向量]是16位)**
      4. $$10H*段基址 + 偏移量$$ ，实际的物理内存地址
   3. 寻找地址
      * 段的首地址存放在段基址中
      * 段的偏移地址存放在寄存器或者使用操作数可以找到

3. 保护模式寻址

   * 4GB的内存寻址空间

   * 虚拟地址 : 实存 + 外存交换空间

   * 虚拟值到物理地址的转换

     * 段基址 + 偏移量

     * 段基址 : 段寄存器给出，但是段寄存器中存放段选择符，从段选择符找到32位的段基址(先找到段描述符) ，在与32偏移量相加得到32位线性地址

     * 段描述符 : (8)字节

       * 段基址
       * 限长
       * 权限

     * 段选择符

       * 存放段描述符的索引
       * 段寄存器中还有段选择符

     * 分页机制

#### 外设

1. 外设和主机的信息交换通过外设接口进行，每个接口中都有一组寄存器，存放交换的数据状态和命令信息
2. 寄存器
   1. 数据
   2. 状态
   3. 命令
3. 每个寄存器都有端口地址和端口号，方便主机访问，端口地址构成了**I/O地址空间**
4. 16位，64KB
5. 编制方式
   1. 独立编制
      1. 不挤占内存空间
      2. 但是需要提供额外的外设指令，复杂
   2. 统一编制
      1. 从内存中分离出地址空间
      2. I/O过多的时候挤占内存，但是找I/O的逻辑简单