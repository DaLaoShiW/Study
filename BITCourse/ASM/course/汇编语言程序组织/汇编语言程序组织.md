## 汇编语言格式

汇编语言中的程序语句可以分成下面几类

* 指令 : 对应有相应的机器码，对应一种CPU操作,**程序运行时执行**
* 伪指令 : 提供给汇编程序信息，伪指令不生成目标代码(除了空间分配的伪指令)，**汇编过程中执行**
* 宏指令 : 用户按照宏定义编写的一段程序，可以包含
  * 指令
  * 伪指令
  * 宏

#### 伪指令

* 数据定义伪指令

  **定义程序中的数据**,为变量分配单元并为其初始化或者预留空间

  1. 变量名称是可选的,是数据区的符号地址,**程序通过变量名引用其中的数据**

  2. **助记符**是数据类型的表示，不区分大小写

     * BYTE
     * WORD
     * DWORD
     * FWORD

  3. 操作数

     * 数字常量

     * 数值表达式

     * 字符串常量 : 

       单引号，字符最好使用ASCII码的形式,其值为字符的ASCII值

     * 地址表达式 :

       *  操作数可以是**地址符号**
       * DB : 符号的偏移量
       * DD : 低字偏移量，高字段基址

     * ? : 为程序预留空间但是不初始化

     * \<n\> DUP(...) : 

       * 对数据重复多次，将其中的内容复制n次，
       * 允许嵌套

  4. 语法格式

     ```asm
     Name 助记符 操作数
     ---
     M1	DB	15,67H,11110000B,?
     M3	DW	4*5
     M4	DD	1234H
     M5	DB	2 DUP(5,'A')    # 重复[5,'A']2次
     M6	DW	M2              # 地址符号表示
     # 
     MOV		BL,M2+2         # M2+2是直接寻址方式，表示我们正在进行M2的地址+2的新地址
     ```

  5. 使用

     * 直接寻址
     * 对数据段中的数据统一寻址

* 符号定义伪指令

  程序中有可能会多次的出现同一个表达式，为了方便起见允许我们加入符号定义伪指令给常用的表达式定义一个符号

  * `EQU`

    1. 语法

       ```asm
       符号名		EQU		表达式
       ```

       使用符号名代表表达式实体或者表达式的值，表达式可以使任何有效的操作数的格式

       * 常数
       * 数值表达式　
       * 另一个符号名
       * 助记符

    2. 举例

       ```asm
       CR	EQU		0DH
       LF	EQU		0AH
       B	EQU		[BP+6]
       ```

    3. 特殊用法

       EQU伪指令可以和`$`符号配合使用功能用于**计算变量分配的字节数**

       ```asm
       MSG		DB		'THIS IS GMFTBY'
       COUNT	EQU		$-MSG
       MOV		AL,COUNT    # count = 14
       XOR		AH,AH
       CALL	PRINTAX    
       ```

    4. 限制

       `EQU`伪指令在同一个程序中不可以重复定义，这一点和`=`是不一样的

  * `=`

    1. 语法

       ```asm
       符号名=20H
       ```

    2. 可以使用功能符号名代替数值(变量)

    3. 限制

       * 常数
       * 数值表达式

    4. 但是可以重复定义，后者覆盖前者

* 结构定义伪指令

  定义另一个数据结构的方式

  1. 结构定义伪指令语法

     ```asm
     NAME	STRUC
     		...
     NAME	ENDS
     ```

     * 结构名由用户起，简称字段名
     * 结构一般放在结构数据分配空间定义之前，数据段之前
     * 可以包含
       * 简单字段
       * 多重字段 : `DUP`

  2. 结构预置空间伪指令

     ```asm
     NAME	STRUC_NAME		<字段值表>
     NAME	STRUC_NAME		n DUP(<>)
     ```

     * 字段值表 <>
     * 字段值之间使用逗号分割
     * 空间赋值不足的时候使用空格填充

  3. 访问结构变量

     * 结构变量名

     * 结构变量名.字段名

       [结构变量名地址].字段名

       段寄存器的默认配置和之前的是一样的

     * 结构变量.字段名[偏移量]

  4. 访问过程

     1. 结构定义在数据段之前
     2. 结构预置在数据段中
     3. 结构访问在代码段中

* 对准伪指令

  1. 格式：EVEN	
    2. 功能：定位到**偶地址**
  2. 说明：
     * 在80X86系列中,由于硬件所采用的设计技术,最好的存储安排是字型数据从字边界开始存放，双字数据从双字边界开始存放，这样可以极大地提高程序的运行效率。	
     * 也可以用ALIGN 4定位到双字地址。


#### 汇编语言操作符

操作符可以出现在语句的操作数表达式中，**在汇编的时候执行**

* 算数操作符

  1. +,-,*,/(只取商),MOD(只取余数)

  2. 算数操作符号可以使用在数值表达式和地址表达式中(地址表达式的时候必须保证地址有明确的物理意义)

     ```asm
     X		DW		12,34,56     # [2100,4300,6500]
     MOV		AX,X+2				 # 明确表示的是X下一个单元的地址(34)
     ```

* 逻辑操作符

  1. AND / OR / XOR / NOT

  2. 都是按位操作，只能用在数值表达式中

  3. 执行的时间不同

     ```asm
     PORT	EQU		0FH
     AND		DL,PORT AND 0FEH    # 前者在执行的时候运行，后者在汇编的时候执行
     ```

* 关系操作符

  1. EQ / NE / LT / LE / GT / GE

  2. 操作结果是一个逻辑值

     * 关系成立结果是真(全1)
     * 关系不成立结果是假(0)

  3. 操作数只能是数字或者是两个存储器的地址

  4. 举例

     ```asm
     MOV		AL,CNT	LT	20
     # CNT < 20
     MOV		AL,0FFH(11111111)
     # CNT >= 20
     MOV		AL,0(00000000)
     ```

* 返回值操作符

  返回值操作符可以将一些特征和内存单元的地址的组成部分当做是数值进行返回

  1. 分类

     * TYPE 变量/标号: 返回变量或者标号的类型的代码

       * DB : 1
       * DW : 2
       * DD : 4
       * 结构体 : 结构占用的字节数
       * 标号
         * NEAR : -1
         * FAR : -2

     * LENGTH 变量 : 对于dup返回n,否则返回1

     * SIZE 变量 : 返回分配的变量的字节数(只对DUP有效)

       **SIZE = TYPE * LENGTH**

     * SEG 变量/标号 : 返回变量或者标号的段基址

     * OFFSET 变量/标号 : 返回变量或者标号的段内偏移量

     * $ : 返回**地址计数器**当前值

* 属性操作符

  属性操作符指定操作数的属性

  1. PTR,THIS,SHORT,HIGH,LOW

  2. PTR

     ```asm
     类型 PTR 地址表达式
     ```

     * PTR经常用在临时改变地址类型或必须明确指出类型的场合

     * 指定地址表达式的类型,**只能出现在操作数的位置，只对当前的指令有效**

       BYTE / WORD / DWORD / FAR / NEAR

     * 举例

       ```asm
       BUF		DB		31H,32H
       MOV		AL,BUF				# AL = 31H
       MOV		BX,WORD PTR BUF	    # BX = 3231H
       LEA		DI,BUF
       MOV		BYTE PTR [DI],6
       ```

  3. THIS

     为存储器操作数指定类型，**该操作数与下一个存储单元具有相同的段基址和偏移量**，需要和指定的EQU伪指令配合

     ```asm
     THIS 类型
     ```

     ```asm
     # 相同存储区域的不同的数据类型
     REDEW	EQU		THIS	WORD
     DEDEW	DB		25H,32H,56H,42H
     ```

  4. LABEL

     ```asm
     名字 LABEL 类型
     ```

     1. 为下一个存储单元起一个名字并定义它的类型，**使同一个地址存在不同的类型和名称**

     2. 对于变量，类型可以是BYTE、WORD、DWORD等。对于标号,其类型可以是NEAR、FAR。LABEL伪指令**并不为名字分配空间**，但它可以为下一个存储单元另起名字而且另定义它的类型，从而可以使同一地址具有不同类型的名字，便于引用。

     3. 举例

        ```asm
        REDEW	LABEL  WORD			
        DEBYTE	DB  25H，32H，56H，42H
        MOV	 	BL，DEBYTE	;(BL)=25H
        MOV	 	CX，REDEW    # CX = 3225H
        ```

  5. SHORT 

     修饰JMP指令的跳转区间的大小

  6. HIGH / LOW

     * 字节分离操作符
     * HIGH取字节，LOW取低字节

#### 汇编语言源程序结构

* 分类
  * 完整段定义
  * 简化段定义

* EXE

  * .EXE文件 是一种可执行程序，它是一个可重定位的装入模块，可以包含多个段，文件的总长度可以超过64K

  * .EXE程序 由文件头和程序本身的二进制代码两部分组成

  * .EXE结构 是DOS普遍采用的一种格式，DOS的大多数应用程序采用.EXE结构,例如FDISK

  * 程序的装入过程

    1. DOS的装入程序为.EXE程序建立一个256字节的程序段前缀PSP。其中PSP:0处存放一条**INT 20H指令**

       ```asm
       INT		20H		# 功能室退出应用程序，释放占用的内存并返回CPU的控制权到操作系统
       ```

    2. 把文件头读入内存工作区

    3. 计算可执行模块的大小

    4. 计算装入的起始段地址

    5. 完成重定位

    6. 初始化段寄存器和指针寄存器

       * CS:IP : 程序的入口地址
       * SS : 堆栈段的段基址寄存器
       * SP : 栈顶
       * 其他的段寄存器全部指向PSP

    7. 把控制权交给.EXE程序。

  * 代码具体解释

    ```asm
    PUSH	DS			# PSP段基址进入堆栈
    XOR		AX,AX		# AX=0
    PUSH	AX			# 0入栈，目的是确定到PSP的0号位置，保证执行INT 20H指令
    MOV		AX,DATA		# DS寄存器并没有正确的指向数据段寄存器，而是指向了PSP的段基址，目的是为了便捷用户可以访问PSP寄存器中的内容
    MOV		DS,AX		# 汇编的时候DATA汇编成一个具体的值(立即数)，立即数不能直接给段寄存器
    ...
    RET					# 因为主过程是FAR类型的，一开始必须先要弹出一个0(AX,IP),最后在弹出PSP段基址(DS),保证当前程序指向的是INT 20H指令

    # 或者是

    MOV		AX ，4C00H  # 4CH->AH,0->AL
    INT		21H
    ```

* COM

  *  .COM文件是一种可执行程序，它的总长度不能超过64K，整个文件只能由一个段组成。
  * 它没有文件头，只包含程序本身的二进制代码
  * 占用内存更少，速度更快，因此适合编制较小的程序

* 程序框架伪指令

  * 段定义伪指令

    ```asm
    Name	SEGMENT     # SEGMENT定义段开始
    		...
    		...
    Name	ENDS		# ENDS定义段的结束
    ```

  * ASSUME

    ```asm
    ASSUME	段寄存器名:段名	# 说明段和段寄存器之间的的关系，该语句应该放在引用段寄存器之前
    ```

  * 过程定义伪指令

    ```asm
    Name	PROC
    		...
    		...
    Name	ENDP
    ```

    * 汇编中的所有的子程序和主程序一律都是使用**过程**的形式实现的
    * .EXE的结果的主过程一定是FAR类型的
    * NEAR - 段内调用，FAR - 段间调用或者段内调用

  * 程序结束伪指令

    ```asm
    END 	过程名
    ```

    * 表示源程序的结束

  * ORG

    * 设置地址计数器内容为数值表达式的值。
    * 在汇编程序对源程序汇编的过程中，使用地址计数器保存当前正在汇编的语句地址（段内偏移量），汇编语言允许用户直接用＄引用地址计数器的当前值
    * 保证下一个存储单元是一个可执行的指令

#### 汇编语言中断

1. 程序的可执行

   1. 建立程序
   2. 编辑程序
   3. 汇编程序
   4. 连接程序
   5. 运行程序

2. 数据的输入输出

   * BIOS中断

     * BIOS : 基本输入输出系统
     * 固化在ROM中，可以使用
     * 基本中断调用
       1. 16H
          * 键盘中断调用
          * 功能号 $$\rightarrow$$ AH
            * 0 : 等待从键盘中读取字符，AL-ASCII码，AH-扫描码
            * 1 : 读键盘缓冲区字符，若ZF＝1，表示缓冲区空;否则表示缓冲区不空，则AL＝ASCII值，AH＝扫描码
            * 2 : 键盘状态字节，AL＝键盘状态字节
              1. shift
              2. ctrl
              3. alt
              4. num lock
              5. scroll lock
              6. caps lock
              7. insert状态
          * INT 16H
       2. 10H
          * 显示器中断调用
          * 屏幕上的每个字符在显示RAM中有两个存储单元相对应,一个存放该字符的ASCII值，另一个存放其属性
          * 功能号 $$\rightarrow$$ AH
            * 0 : AL＝显示模式
            * 6 : 初始化窗口或窗口内容向上卷动
            * 2 : 设置光标位置
            * 3 : 读光标位置
            * 9 : 在当前光标位置显示属性和字符,因此当用此功能显示完字符后还需处理光标
            * 0EH : 该功能较强，它在显示字符后可以对光标做必要的处理
            * 13H : 显示字符串及属性
          * INT 10H

   * DOS中断

     * 相对BIOS更高级的中断，也可以使用BIOS中断

     * 每种操作系统都为用户提供了使用输入输出设备的系统资源，它们对硬件的依赖性更少，兼容性较好、使用更方便

     * 功能号 $$\rightarrow$$ AH

       * 1 : **带回显**的字符输入并识别Ctrl-C键,AL＝输入字符的ASCII值

       * 2 : 输出一个字符，DL＝字符的ASCII值

       * 0AH : 输入字符串

         1. DS:DX指向自定义的输入缓冲区首地址
         2. 输入一串字符到用户定义的缓冲区,直到按下Enter键为止,在接收的同时显示到屏幕上，并且识别Ctrl-C键
         3. 自定义的缓冲区应该是**字节型**的
            1. 用户自定义的缓冲区的最大大小
            2. 数据输入的字符的数目，包含回车

       * 9 : 输出字符串

         DS:DX指向要输出的以＄结尾(**必须**)的字符串首地址

     * INT 21H

#### 微处理器伪指令

1. .286 / .386 / .486 / .586 / .8087 / .287 / .387 (.8087, .287, .387数字协处理器)

2. 简化段定义的常用结构

   * 当.386**等**选择处理器伪指令出现在.model之前时表示缺省选择32位指令模式，出现在.model之后时表示缺省选择16位指令模式

     ```asm
     .MODEL SMALL	;定义内存模式为小模式
     .586			;选择处理器  16位
     .STACK 512		;定义堆栈段及其尺寸为512字节
     .DATA			;数据段开始
     ;数据在此处定义
     .CODE			;代码段开始
     .STARTUP		;加载后程序入口点
     ;代码在此处定义
     .EXIT			;返回DOS或父程序
      END			;整个程序结束
     ```

   * 常用伪指令

     * .model : 存储模型伪指令

     * .stack size : 建立一个堆栈段并定义大小

     * 预定义符号

       1. @CODE：代码段段名
       2. @DATA：由.DATA和.STACK定义的段集合成的组名
       3. @FARDATA：独立数据段的段名

       ```asm
       MOV		AX，@DATA
       MOV		DS，AX
       ```

     * 当.386等选择处理器伪指令出现在.model伪指令之前时不能用.startup和.exit，否则汇编时出错。

#### Windows 程序执行环境

1. Windows内存布局		

   * 虚拟内存		
   * “平坦”内存模式		
   * 内存布局		
   * 段选择符和段描述符信息

2. Windows的保护机制		

   特权级+类型检查

3. 用户界面