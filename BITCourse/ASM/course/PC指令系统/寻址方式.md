## PC指令系统

1. 一台计算机拥有的全部的指令集和构成指令系统(指令集)

2. 指令 : 操作码 + 操作数

3. 什么是寻址方式

   指令按照什么方式寻找对应的操作数和操作数地址，**源操作数**和**目标操作数**都涉及到我们的寻址问题

4. 分类

   - 数据有关的寻址方式
   - 转移地址有关的寻址方式

### 数据寻址方式

#### 立即寻址方式

* 操作数直接包含在指令中，紧跟在操作码之后的寻址方式为立即寻址方式，该操作数称之为是立即数

#### 寄存器寻址方式

* 操作数直接包含在寄存器中
* 目标寄存器不可以使**CS**

#### 直接寻址方式

* 操作数的有效地址直接包含在指令中的寻址方式称之为是直接寻址方式

* 操作数在内存中

* 计算方式

  1. 变量 : DS + EA(偏移地址)

     默认DS段

  2. 字符串的指令的源地址 : DS段

  3. 字符串的指令的目标地址 : ES段

  4. BP,EBP默认的段寄存器 : SS段

* 语法

  * ```asm
    MOV		AX,[78H]
    ```

  * ```asm
    MOV		AX,VAR    ; VAR一般是数据段中的定义的内存中的变量
    ```

* 使用段超越的话，可以修改默认的制定配合的段基址寄存器，使我们将偏移地址执行一个指定的段

#### 寄存器间接寻址

* 操作数的有效地址在寄存器中，但是操作数在内存中的寻址是寄存器间接寻址方式

* 限制

  1. 8086 : BX,BP,SI,DI
  2. 8086+ : 通用寄存器
  3. BX,SI,DI - DS
  4. BP - SS

* 语法

  ```asm
  MOV		AX,[BP]
  ```

#### 寄存器相对寻址方式

* 操作数的有效地址 : 寄存器的内容和一个指定的**偏移量(立即数或者是内存中的变量)**的和

* 限制

  1. 8086 : BX,BP,SI,DI
  2. 8086+ : 通用寄存器
  3. BP,SP - SS
  4. BX等通用寄存器 - DS

* 语法

  ```asm
  MOV		AL,[BX+8]
  MOV		AL,8[BX]
  ```

* 理解

  * DS + BX + disp(可变)

  * ```asm
    MOV		AL,[BX+TABLE]    ; TABLE是一维数组的首地址可以通过动态的修改BX实现对数组内容的动态访问,BX是偏移地址 * (数组单位长度)字节数
    ```

#### 基址变址寻址方式

* 操作数的**有效地址**(在DS中的地址) : 
  * 8086 : 基址寄存器和变址寄存器内容之和
  * 8086+ : 只要ESP不重复使用即可
* 限制
  * BX等通用寄存器 - DS
  * BP,ESP,EBP - SS
* 应用
  * DS + BX + SI(可变)
  * 访问一维数组(详见test1.asm)
    1. 基址寄存器BX存放数组的首地址
    2. 变址寄存器存放偏移地址(必须要和数组的单位长度相乘才可以使用)

#### 相对基址变址寻址方式

* 操作数的有效地址:

  * 8086 : 基址寄存器和变址寄存器和一个制定的**变量(立即数或者是内存变量)**的和
  * 8086+ : 只要两个寄存器不重复使用ESP即可(变址不可以使用)

* 限制

  * BP,EBP,ESP - SS
  * BX等通用寄存器 - DS

* 应用

  可以用来访问二维数组

  BX,SI都需要乘对应的数组单位长度的字节数

  ```asm
  MOV		AX,ARY[BX+SI]	;MOV	AX,[BX+SI+ARY],ARY是二维数组的首地址
  ```

#### 比例变址寻址方式

* 限制

  1. 只适合80386以上的机器

* 操作数的有效地址 :

  * 基址寄存器和**变址寄存器(除ESP)乘以比例系数(1,2,4,8)**再加上相对偏移地址长度
  * 不同的比例系数可以用来寻址不同的单位长度的数组变量

* 应用

  ```asm
  MOV		AX,[EAX+2*EDX]
  ```

### 转移地址寻址方式

1. 举例

   ```asm
   JMP		DESTINATION		;DESTINATION可以分为段间转移和段内转移，并且每一类又可以分为直接转移和间接转移
   ```

   * 段内转移 : 只影响IP,EIP
   * 段间转移 : IP/EIP + CS

#### 段内直接寻址

* 转移的有效地址:

  当前的指令指针寄存器(IP)和指令中的偏移量(**带符号整数,和IP加时需要带符号扩展**)的和

* 短转移(8位)

  ```asm
  JMP		SHORT	LAB		;LAB是转向的目标地址的符号表示
  ```

* 近转移(16位)

  ```asm
  JMP		NEAR	PTR		LAB		;JMP	LAB
  ```

#### 段内间接寻址

* 转移的有效地址 : 

  在寄存器或者内存单元中，将其中的有效地址传给IP/EIP,实现转移的操作

* 应用

  ```asm
  JMP		BX						; 寄存器
  JMP		WORD	PTR		VAR 	; 内存单元
  JMP		WORD	PTR		[BX]	; DS段
  ```

#### 段间直接寻址

* 转移的有效地址 :

  1. 指令中明确的给出转义的**偏移量和段基址**
  2. 段基址->CS,偏移量->IP

* 语法

  ```asm
  JMP		FAR		PTR		LAB		;LAB是行号
  ```

#### 段间间接转移

* 转移的有效地址

  1. 双字的内存变量 : 低16字节IP,高16字节CS

* 应用

  ```asm
  JMP		DWORD	PTR		[BX]	; BX指向的内存地址的双字
  ```



### 数据传送指令

1. MOV

   * ```asm
     MOV	DST,SRC		; SRC->DST
     ```

   * 字节，字，双字的数据传送

   * 限制

     * 立即数不可以是目的操作数
     * 立即数不可送往段寄存器
     * 目标操作数不可以是CS寄存器
     * 段寄存器之间不可以传送
     * 存储器单元之间不可以直接传送
     * 通用寄存器之间可以随意的传送数据

   * 特殊使用

     * ```asm
       MOV		AX,SEG TAB		; 将TAB的段基址送给AX寄存器
       MOV		AX,OFFSET TAB	; 将TAB的偏移量送给AX寄存器
       ```

2. MOVSX

   * ```asm
     MOVSX	DST,SRC		; SRC->DST,DST空出的位用SRC符号位填充
     ```

   * 386+

3. MOVZX

   - ```asm
     MOVZX	DST,SRC		; SRC->DST,DST空出的位用0填充
     ```

   - 386+

4. PUSH

   - ```asm
     PUSH	SRC
     ```

   - 修正栈顶指针(高地址->低地址,减) + 写入数据

   - 8086 : 只可以使16位寄存器或者存储器

5. POP

   - ```asm
     POP		DST
     ```

   - 修正栈顶指针(高地址->低地址,加)

   - 8086 : 只可以使16位寄存器或者存储器

6. PUSHA & POPA

   * 将所有(8)的16位通用寄存器进栈
   * 将所有(8)的16位通用寄存器出栈

7. IN

   * ```asm
     IN	ACR,PORT	; 外设端口PORT的内容传给累加器寄存器
     ```

   * 对应关系

     * 8byte - AL
     * 16byte - AX
     * 32byte - EAX

   * 说明

     * PORT(0~255) : 端口号直接在指令中(立即数的形式)
     * PORT(>255) : 端口号必须放在DX间接寻址

8. OUT

   * ```asm
     OUT	PORT,ACR	; 累加器的内容写到外设的端口上
     ```

   * 要求和IN一致

9. XLAT

   * 查表转换指令
   * 通过AL寄存器的索引值在表中查得项的内容返回给AL
   * 说明
     * 数据段中提前建立一个**字节型表(可以当做是ASCII码值的存储，依据索引查询ASCII码)**
     * 表的起始地址的偏移量放入BX中
     * 表索引放入AL中
     * 结果存放在AL中

10. LEA

  * 传送操作数的地址，不传送操作数本身

  * ```asm
    LEA		REG,SRC
    ```

  * 只能是**存储器操作数(可以采用不同的寻址方式指向存储器操作数)**

11. 标志传送指令组

    * PUSHF
      * 将标志寄存器内容保护进堆栈
    * POPF
      * 将标志寄存器内容弹出堆栈
    * PUSHFD
    * POPFD
    * LAHF
      * 标志寄存器的低8位送至AH
    * SAHF
      * AH送至标志寄存器低8位

12. 算数运算指令

    * 限制
      1. 目标操作数不允许是立即数或者是CS寄存器
      2. 两个操作数不可以同时是存储器操作数
    * 数据
      1. 数据在机器中采用二进制补码存储
      2. 数据在进行运算的时候会自动汇编成二进制的形式

    1. CBW

       * 将AL寄存器中的**符号位**值扩展到AH中

    2. CWD

       * 将AX寄存器中的**符号位**扩展到DX寄存器中

    3. CDQ

       * 将EAX寄存器的符号位扩展到EDX中
       * 80386+

    4. ADD

       * 适用于带符号和无符号数
       * 影响标志寄存器的相关位

    5. ADC

       * 带进位的加法指令，加法中考虑加入了CF的值
       * 影响标志寄存器的相关位
       * 可以用来实现超长计算的加法(项低位的字节的加法结果溢出至CF中作为进位传递给高位)

    6. INC

       * 增1
       * **循环**实现+1操作，不影响CF标志位但是会影响其他的标志位

    7. 关于溢出的注意点

       * 计算的数如果看待的方式不一样，结果也会不一样

         看待成是带符号数有可能会溢出(OF)看待成无符号数也有可能会溢出(OF)

    8. SUB

       * 减法的功能
       * 修改和影响标志寄存器的相关位
       * **多字节的减法的溢出考虑的都是最高位的CF/OF的情况**

    9. SBB

       * 带借位减法的指令SBB
       * 计算的时候还需要考虑减去CF位

    10. DEC

      * 方便实现循环的减1的操作
      * 不影响CF位，但是可能会影响其他的标志位

    11. CMP

        * ```asm
          CMP	DST,SRC
          ```

        * 计算不修改操作数的值，只会修改标志位，常用来比较两个数的大小

        * 可以理解成是预减法

    12. NEG

        * 对目标操作数(**含符号位**)取反+1,并修改操作数的结果
        * 可以用来求相反数

    13. MUL

        * ```asm
          MUL	SRC
          ```

        * 操作数不可以是立即数，只能是寄存器值或者是存储器的值

        * **无符号数**的相乘

        * 对应关系

          1. 8 - AL - AX
          2. 16 - AX - DX:AX
          3. 32 - EAX - EDX:EAX

        * 如果计算的结果对于乘积的高半部分是0,CF/OF=0否则置1

    14. IMUL

        * ```asm
          IML	SRC
          IML	REG,SRC		; SRC * REG -> REG,如果结果存放正确则CF/OF=0,否则是1
          ```

        * 带符号的数相乘

        * 基本使用功能方法同MUL

    15. DIV

        * ```asm
          DIV	SRC		; SRC是除数，只能是存储器操作数或者寄存器操作数
          ```

        * 对应关系

          1. 8 - $$AX \div SRC$$ -$$AL商，AH余数$$
          2. 16 - $$DX:AX \div SRC$$ - $$AX商，DX余数$$
          3. 32 - $$EDX:EAX \div SRC$$ - $$EAX商,EDX余数$$


### 逻辑指令

```asm
# 逻辑指令
NOT	DST		; DST取反送入DST
AND	DST,SRC		; DST & SRC -> DST,清零CF/OF
TEST	OPR1,OPR2	; 不保存结果的AND,修改标志位
OR	DST,SRC		; DST | SRC -> DST,修改标志位
XOR	DST,SRC		; 影响标志位
# --------------------------------------------
# 位测试指令
BT	DST,SRC		; 测试由SRC指定的DST的位，将所选的位的值送到CF中，不改变其他的标志位
BTS	DST,SRC		; 位测试并置1,其他同上
BTR	DST,SRC		; 位测试并清0,其他要求同上
BTC	DST,SRC		; 测试并取反制定的位，其他要求同上
# --------------------------------------------
# 位扫描指令
BSF	DST,SRC		; 顺序扫描指令，从右向左扫描将SRC中的第一个为1的位的位号送入DST
BSR	DST,SRC		; 方向同上
# --------------------------------------------
# 基本移位指令,CNT是移位数放在CL，DST是操作数，移除位放在CF，用0补全
SHL	DST,CNT		; 逻辑左移
SAL	DST,CNT		; 算数右移,同上
SHR	DST,CNT		; 逻辑右移
SAR	DST,CNT		; 算数右移，用符号位补全
# --------------------------------------------
# 循环移位指令，移除位在CF中
ROL	DST,CNT		; 循环左移
ROR	DST,CNT		; 循环右移
RCL	DST,CNT		; 带进位循环左移
RCR	DST,CNT		; 带进位循环右移
```

### 程序控制指令

控制程序的流程

* 条件转移指令
  1. 不可以实现**段间转移指令**
  2. 当满足条件之后转义到程序的另一处执行，本系统提供多个条件转移指令使用，一般都需要使用标志位判断是否进行**转移**
  3. 如果条件为真转移，否则程序顺序执行

* 条件转义指令表

  ```asm
  # 无符号进位转移
  JC	LABEL		; CF=1转移
  JNC	LABEL		; CF=0转移
  # 有符号溢出转移
  JO	LABEL		; OF=1转移
  JNO	LABEL		; OF=0转移
  # 奇偶转移指令,PF
  JP	LABEL
  JNP	LABEL
  # 负数转移指令,SF
  JS	LABEL
  JNS	LABEL
  # 相等转移指令,ZF
  JZ/JE	LABEL
  JNZ/JNE	LABEL
  # 大小比较转移指令,E=equal,N=not,L=little,G=big
  JG/JNLE	LABEL	; >,>=
  JNG/JLE	LABEL	; <=,<
  JL/JNGE	LABEL

  # N=not,A=above,B=below
  JA/JNBE
  JNA/JBE
  JB/JNAE/JC
  JNB/JAE/JNC

  # 测试CX,=0转移
  JCXZ
  JECXZ
  ```

* 循环指令

  ```asm
  LOOP	LABEL
  ```

  * CX -= 1,CX不为0继续执行循环指令

* 子程序调用指令

  * 汇编中的子程序相当于是C中的函数，实现了模块化和共享的操作

  * 子程序结束后返回到主程序执行

  * ```asm
    ; 段内直接调用
    CALL	DST		; 调用子程序，先将返回地址压栈，在形成子程序的入口地址将CPU的控制权交接给子程序
    ; DST是子程序名或者子程序的入口地址

    ; 段内间接调用
    CALL	REG		; REG是寄存器或者是内存单元地址，将其中的存放的地址转交给IP执行子程序
    CALL	EBX		; EBX中存放子程序的入口首地址

    ; 段间直接调用
    CALL	FAR		PTR		PROCEDURE		; 调用PROCEDURE子程序，执行的时候将返回地址压栈，再将指令中偏移量部分送到IP，段基址送给CS,控制权转交给子程序

    ; 段间间接调用
    CALL	M								; 先将返回地址压栈(IP,CS),M对应的地址的高16字节CS,转交CPU的控制权
    ```

  * 和JMP的区别

    * 需要返回，所以保存返回的地址，但是JMP没有必要

  * RET指令

    弹出压入的返回地址，返回主程序执行

    ```asm
    RET
    RET	imm16		; 返回主程序并修改栈顶指针SP,目的是为了废除主程序中传递的参数，但是参数的值如果还想要可以用BP获取
    ```

* 中断调用指令

  1. 中断向量

     * 中断向量就是中断处理子程序的**入口地址(服务程序)**
     * 每个中断向量占有4个字节
       * 低2字节 : 中断向量偏移地址
       * 高2字节 : 中断向量的段基址
     * 256中中断，称之为是中断类型号

  2. 中断向量表

     * 256个中断向量按照中断类型号排列成一张表
     * 1KB

  3. INT

     * 内中断调用指令

     * ```asm
       INT	n		; n是中断类型号
       ```

     * 终端当前执行的程序，保护现场

     * 4n->IP,4n+2->CS,执行中断处理**子程序**

  4. IRET

     * 中断返回指令

       从中断处理子程序中返回的时候需要使用中断返回指令，中断返回指令应该放在中断处理子程序的末尾

     * 恢复现场，转交控制权还给主程序

### 处理机控制指令

#### 标志操作指令 P83

只影响指令设涉及的标志位

#### 其他处理机控制指令

不影响标志位，但是可以控制处理机的状态

* NOP : PASS空转
* HLT : CPU停机
* WAIT : CPU等待
* LOCK : 总线锁定信号有效

### 串操作指令

使用串操作指令可以直接处理两个**存储器操作数**，方便处理**字符串和数据块**

1. 指令格式
   * 字节型
   * 字型
   * 双字型
2. 操作数
   * 串指令可以处理寄存器操作数和存储器操作数
     * 寄存器操作数只能在AL,AX,EAX
     * 存储器操作数必须先要建立地址指针
       * SI : DS
       * DI : ES (p37)
       * 理论上只能实现DS->ES(但是可以通过将ES和DS的段起始地址重复实现DS->DS)
3. 方向标志位
   * DF决定地址指针的变化方向
     * 0 : ++
     * 1 : --
     * **可以使用标志操作指令实现修改**
4. 重复前缀
   * 一条串指令可以处理一串数据的能力在于增加前重复前缀实现
   * 重复次数在CX中，类似于循环(CX=0一次操作也不执行，但是在LOOP中不是这样的)
   * REP
     * 消耗CX实现重复前缀
   * REPR
     * CX=0 || ZF=0(不等)结束重复
   * REPNE
     * CX=0 || ZF=1结束重复
5. 指令
   * MOVS
     * MOVSB / MOVSW / MOVSD
   * LODS
     * LODSB / LODSW / LODSD
     * 取串指令到AL,AX,EAX
   * STOS
     * STOSB / STOSW / STOSD
     * 存串指令AL,AX,EAX
   * INS / OUTS
     * **内存和外设**之间的数据块传送
     * IN / OUT是**CPU和外设**之间的数据传送指令
     * 端口号事先存放在DX寄存器中
   * CMPS
     * CMPSB / CMPSW / CMPSD
     * 需要重复前缀
   * SCAS　DST
     * 实现在内存中的一段数据中查找某一个数据的功能
     * SCASB / SCASW / SCASD
     * 需要重复前缀
     * 修改ZF标志位
     * DST : AL,AX,EAX



